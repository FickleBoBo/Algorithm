https://www.acmicpc.net/problem/16235

![alt text](사진1.png)
![alt text](사진2.png)
![alt text](사진3.png)

# 🔍 나무 재테크(실패)
- 설계 시간 : 6min / 10min
- 구현 시간 : 0min / 72min
- 난이도 : 골드 3
- 알고리즘 : 구현 / 자료구조 / 시뮬레이션
- 코드 길이 : B
- 실행 시간 : 제한 0.3초
- 메모리 : KB

---

# 💡 아이디어

- 맵에 대한 정보를 2차원 배열로 다루고 2차원 배열의 각 칸(arr[row][col]) 에 대해 나무 정보(나이)를 쭉 달아주면 될듯?
  - 3차원 배열을 꼭 써야하는 문제를 딱히 본 적도 없고 나무 나이를 담는 3차원에서 배열 길이를 임의로 정해야 하는가 고민이 됨
  - 가변적인 길이니까 2차원 배열의 각 칸에 ArrayList의 주소를 담으면 되겠네 -> 문법이 틀렸다고 나옴
  - 그냥 배열 길이를 무지성 길게 해놓고 되기는 하나 시도해봄
  - 시간 초과가 나더라도 안될건 없어보였는데, 테케 구현도 실패함
- 이거는 내가 못하는 문제다 생각해서 포기함

---

# 🧠 어려웠던 점

- 시간 제한 0.3초면 무지성으로 하면 안되는 문제인데 접근부터 모르겠었음

---

# 🧐 좋은 풀이

- 잘 푼거 같은 사람 코드 가져옴

---

# 🙄 생각해볼 점

- 나무 클래스에 compareTo를 만들어 놓고, 이후 비교 관련 코드가 없었는데 DeQueue에 나이순으로 정렬된거 마냥 들어가는건가 잘 모르겠음
  - 나무 인스턴스를 담은 DeQueue는 나무 나이 순서로 자료가 들어있어야 할 거 같음(매번 정렬하면 시간 초과 남)
  - 가을에 새로운 나무를 추가할 때는 addFirst를 했는데 뭐지?
  - compareTo 아무쓸모 없는거 같은데?
  - 그냥 우연?찮게 나무 입력이 나이순으로 들어오는건가 -> 우선 순위 큐가 맞는 구현인듯?
- for문과 for-each문 2가지가 있는데, LinkedList의 원소 순회에서는 for-each가 훨씬 빠르다는 블로그 글을 봄(진짠지는 모름...)
- ArrayList와 LinkedList에서 추가, 삭제가 많으면 LinkedList, 검색이 많으면 ArrayList 사용 권장(그럴거 같음)
- 출력을 할 때 버퍼드리더랑 스트링빌더 중 뭘 쓸까
- list에서 삭제 연산은 안전하고 빠른 iterator의 사용을 권장하는 글을 봄(진짠지는 모름)
  - 순회 관련 클래스? 같은거인듯
