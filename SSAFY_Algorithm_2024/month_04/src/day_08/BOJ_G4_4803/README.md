# 🔍 트리
- 설계 시간 : 1min
- 구현 시간 : 136min
- 난이도 : 골드 4
- 알고리즘 : 그래프 / 트리 / DFS / 분리 집합?
- 코드 길이 : 1678B
- 실행 시간 : 1104ms(제한 1초)
- 메모리 : 294364KB

------------------------------

# 💡 아이디어

- 유니온 파인드로 그래프를 그룹화하고 각 그래프에서 노드 수 -1 이 간선의 수이면 바로 트리구나(노드 1개짜리 트리도 성립)

------------------------------

# 🧠 어려웠던 점

- 하나의 그래프에서 노드 수-1 == 간선의 수 면 트리인걸 까먹음
- 유니온 파인드의 p 배열에서 자기 자신을 참조하도록 처음에 짜는거 때문에 트리도 노드 수랑 간선 수가 동일하게 나옴
  - 이거는 해결이 안돼서 간선을 세는 배열을 결국 만듦
- 간선을 세는 건 유니온 메서드에서 해야하는데 간선이 전부 그룹장에게 붙어야 저 식대로 됨
  - 기묘하게 잘 입력이 들어오면 간선이 따로 노는걸 발견에서 전부 그룹장에게 붙이는 처리를 해줘야함
- 패스 컴프레션을 적용했는데 패스 컴프레션은 그룹장에게 다시 붙이는 과정에서 간선 연결관계가 바뀌어서 그래프가 트리로 판정이 날 수 있음
  - 이거를 초창기에 발견해서 아마 위에꺼 적용하면 그냥 스무스하게 넘어갈 수도 있을 거 같음
- 대회 테케 찾아봤는데 32개중 3개가 트리가 조금 적게 나와서 계속 오류를 찾았는데 counting 과정에서 find로 붙여주니 바로 통과됨
- 아마 그동안 있던 오류 전부 두개의 커다란 그래프를 하나로 붙일 때 발생할 것으로 추측함(자작 테케는 잘됐음)

------------------------------

# 🧐 좋은 풀이

- BFS 같은 걸로 하면 다들 스무스하게 통과됐는데 유니온 파인드로 한 사람이 주로 고통받은 듯
- 유니온 파인드는 트리 구별도 어렵고 패스 컴프레션에서 간선 연결관계도 바뀌니 그냥 그래프 개수나 그래프의 노드 수를 구하는 상황에서 써야될 듯
