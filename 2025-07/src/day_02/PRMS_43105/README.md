# [PRMS 43105 - 정수 삼각형](https://school.programmers.co.kr/learn/courses/30/lessons/43105)

## 문제 설명

![](./assets/photo1.png)

위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다.

삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요.

## 제한사항

- 삼각형의 높이는 1 이상 500 이하입니다.
- 삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수입니다.

## 입출력 예

| triangle                                                | result |
| ------------------------------------------------------- | ------ |
| [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]] | 30     |

---

## 문제 정보

| 티어   | Lv. 3 |
| ------ | ----- |
| 정답률 | 63%   |

## 풀이 정보

| 풀이 시간 | 9 min               |
| --------- | ------------------- |
| 알고리즘  | 다이나믹 프로그래밍 |

| 정확성 테스트                     |
| --------------------------------- |
| 테스트 1 〉 통과 (0.05ms, 78.9MB) |
| 테스트 2 〉 통과 (0.03ms, 84.7MB) |
| 테스트 3 〉 통과 (0.05ms, 73.9MB) |
| 테스트 4 〉 통과 (0.07ms, 79.8MB) |
| 테스트 5 〉 통과 (0.24ms, 81.3MB) |
| 테스트 6 〉 통과 (0.10ms, 84.7MB) |
| 테스트 7 〉 통과 (0.25ms, 76MB)   |
| 테스트 8 〉 통과 (0.08ms, 88MB)   |
| 테스트 9 〉 통과 (0.05ms, 93.8MB) |
| 테스트 10 〉 통과 (0.08ms, 90MB)  |

| 효율성 테스트                      |
| ---------------------------------- |
| 테스트 1 〉 통과 (8.08ms, 63.6MB)  |
| 테스트 2 〉 통과 (8.51ms, 62.6MB)  |
| 테스트 3 〉 통과 (7.84ms, 64MB)    |
| 테스트 4 〉 통과 (7.27ms, 62.3MB)  |
| 테스트 5 〉 통과 (7.56ms, 62.9MB)  |
| 테스트 6 〉 통과 (7.85ms, 64.1MB)  |
| 테스트 7 〉 통과 (7.95ms, 63.1MB)  |
| 테스트 8 〉 통과 (7.91ms, 62.8MB)  |
| 테스트 9 〉 통과 (7.26ms, 65.6MB)  |
| 테스트 10 〉 통과 (7.31ms, 65.3MB) |

## 코드

```java
class Solution {
    public int solution(int[][] triangle) {
        int N = triangle.length;

        // 특정 위치까지 이동하는데 거쳐간 숫자의 최댓값을 저장
        int[][] dp = new int[1 + N][1 + N];

        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= i; j++) {

                // 특정 위치까지 이동하는데 거쳐간 숫자의 최댓값 = 해당 위치로 오기 직전 위치까지 이동하는데 거쳐간 숫자의 최댓값 + 해당 위치의 숫자
                dp[i][j] = Math.max(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i - 1][j - 1];
            }
        }

        int max = 0;
        for (int num : dp[N]) {
            max = Math.max(max, num);
        }

        return max;
    }
}
```

## 해설

삼각형의 높이가 최대 500이어서 DFS를 통한 완전탐색으로는 어려울 것으로 판단해서 다이나믹 프로그래밍으로 접근했다.

다이나믹 프로그래밍은 바닥의 특정 위치에 도달하기 위해 거쳐간 숫자의 최댓값은 바닥의 특정 위치에 도달할 수 있는 직전 위치들 중 가장 거쳐간 숫자의 합이 큰 경로에서 바닥을 방문하면 된다. 이 과정이 꼭대기까지 반복되므로 점화식을 세워서 해결할 수 있다.

주어진 2차원 배열 triangle을 아래와 같이 보기 좋게 표현할 수 있다.

```
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

다이나믹 프로그래밍의 2차원 배열은 꼭대기에서 인덱스 처리를 간소화하기위해 왼쪽과 위쪽에 패딩을 주었다. 삼각형 위치를 넘어가는 인덱스 역시 계산이 불필요하므로 순회 범위를 제한해줬다.

```
0
0 7
0 10 15
0 18 16 15
0 20 25 20 19
0 24 30 27 26 24
```

## 리뷰

- 무난한 기본 DP 유형
