Stack 자료구조를 이용해 구현
- 입력 받은 값을 toCharArr 메소드로 char[] 로 만들어 줌
- for문을 돌며 char[]의 인덱스에 대한 stack을 만듦
- ( : 만나면 stack에 index를 push
- ) : 만나면 stack에서 index를 pop
  - pop이 push 바로 직후 일어났으면 -> 레이저
  - pop이 pop 이후 일어났으면 -> 쇠막대기
- 레이저가 지나간 쇠막대기의 총 수(중복O) + 쇠막대기의 개수 = 절단된 개수

쇠막대기
- char[] 길이만큼 배열을 생성 후 쇠막대기가 있는 영역의 모든 인덱스를 +1
- 배열 생성과 인덱스+1 과정에서 시간 손해가 있고, 절단 수를 찾을 때 시간 이득이 있는 것 같음(이득이 더 큼)

레이저
- index를 쭉 push하다가 절단 수를 찾는 과정에서 isEmpty 까지 pop
- 레이저가 실제로는 중간(ex 0.5, 5.5)에 있지만 앞쪽 index와의 비교로도 같게 구할 수 있음
- 쇠막대기[레이저.pop()]으로 카운팅 배열처럼 구할 수 있음

배운점
- 극한의 시간 단축을 위해 다양한 시도를 해보며 느낄 수 있었다
  - 쇠막대기 : 배열순회(순, 역) -> List<int[]> -> int[]
  - 레이저 : int[] -> stack
  - Scanner -> BufferedReader
  - 문자열.split("") -> 문자열.toCharArray()
- 자구 & 알고 다양한 경험이 필요함(stack인줄 몰랐으면 못풀거 같음)

아쉬웠던 점
- 아슬아슬한 pass여서 좋은 풀이는 아닌듯 함
- StringTokenizer 인가 어케 쓰나 몰라서 못함(이게 더 빠를까 기대됨)
- 쇠막대기와 레이저를 구분하는 과정이 시간을 잡아먹는 파트 같아서 줄이고 싶었는데 실패함


레이저와 쇠막대기의 구분
|(|)|(|(|(|(|)|(|)|)|(|(|)|)|(|)|)|)|(|(|)|)|
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
| | | | | | | | | | | | | | | | | | | | | | |
|(|)| | | |(|)|(|)| | |(|)| |(|)| | | |(|)| |
| | |(|(|(| | | | |)|(| | |)| | |)|)|(| | |)|
| | | | | | | | | | | | | | | | | | | | | | |
| | | | |-|-|-|-|-|-| | | | | | | | | | | | |
| | | | | | | | | | |-|-|-|-| | | | |-|-|-|-|
| | | |-|-|-|-|-|-|-|-|-|-|-|-|-|-| | | | | |
| | |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-| | | | |
| | | | | | | | | | | | | | | | | | | | | | |
|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
