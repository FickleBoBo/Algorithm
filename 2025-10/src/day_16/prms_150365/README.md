# [Programmers 150365 - 미로 탈출 명령어](https://school.programmers.co.kr/learn/courses/30/lessons/150365)

## 문제 설명

`n` x `m` 격자 미로가 주어집니다. 당신은 미로의 (x, y)에서 출발해 (r, c)로 이동해서 탈출해야 합니다.

단, 미로를 탈출하는 조건이 세 가지 있습니다.

1. 격자의 바깥으로는 나갈 수 없습니다.
2. (x, y)에서 (r, c)까지 이동하는 거리가 총 `k`여야 합니다. 이때, (x, y)와 (r, c)격자를 포함해, 같은 격자를 두 번 이상 방문해도 됩니다.
3. 미로에서 탈출한 경로를 문자열로 나타냈을 때, 문자열이 사전 순으로 가장 빠른 경로로 탈출해야 합니다.

이동 경로는 다음과 같이 문자열로 바꿀 수 있습니다.

- l: 왼쪽으로 한 칸 이동
- r: 오른쪽으로 한 칸 이동
- u: 위쪽으로 한 칸 이동
- d: 아래쪽으로 한 칸 이동

예를 들어, 왼쪽으로 한 칸, 위로 한 칸, 왼쪽으로 한 칸 움직였다면, 문자열 `"lul"`로 나타낼 수 있습니다.

미로에서는 인접한 상, 하, 좌, 우 격자로 한 칸씩 이동할 수 있습니다.

예를 들어 다음과 같이 3 x 4 격자가 있다고 가정해 보겠습니다.

```
....
..S.
E...
```

미로의 좌측 상단은 (1, 1)이고 우측 하단은 (3, 4)입니다. `.`은 빈 공간, `S`는 출발 지점, `E`는 탈출 지점입니다.

탈출까지 이동해야 하는 거리 `k`가 5라면 다음과 같은 경로로 탈출할 수 있습니다.

1. lldud
2. ulldd
3. rdlll
4. dllrl
5. dllud
6. ...

이때 dllrl보다 사전 순으로 빠른 경로로 탈출할 수는 없습니다.

격자의 크기를 뜻하는 정수 `n`, `m`, 출발 위치를 뜻하는 정수 `x`, `y`, 탈출 지점을 뜻하는 정수 `r`, `c`, 탈출까지 이동해야 하는 거리를 뜻하는 정수 `k`가 매개변수로 주어집니다. 이때, 미로를 탈출하기 위한 경로를 return 하도록 solution 함수를 완성해주세요. 단, 위 조건대로 미로를 탈출할 수 없는 경우 `"impossible"`을 return 해야 합니다.

## 제한 사항

- 2 ≤ `n` (= 미로의 세로 길이) ≤ 50
- 2 ≤ `m` (= 미로의 가로 길이) ≤ 50
- 1 ≤ `x` ≤ `n`
- 1 ≤ `y` ≤ `m`
- 1 ≤ `r` ≤ `n`
- 1 ≤ `c` ≤ `m`
- (`x`, `y`) ≠ (`r`, `c`)
- 1 ≤ `k` ≤ 2,500

## 입출력 예

| n   | m   | x   | y   | r   | c   | k   | result       |
| --- | --- | --- | --- | --- | --- | --- | ------------ |
| 3   | 4   | 2   | 3   | 3   | 1   | 5   | "dllrl"      |
| 2   | 2   | 1   | 1   | 2   | 2   | 2   | "dr"         |
| 3   | 3   | 1   | 2   | 3   | 3   | 4   | "impossible" |

## 입출력 예 설명

입출력 예 #1

문제 예시와 동일합니다.

입출력 예 #2

미로의 크기는 2 x 2입니다. 출발 지점은 (1, 1)이고, 탈출 지점은 (2, 2)입니다.

빈 공간은 `.`, 출발 지점을 `S`, 탈출 지점을 `E`로 나타내면 다음과 같습니다.

```
S.
.E
```

미로의 좌측 상단은 (1, 1)이고 우측 하단은 (2, 2)입니다.

탈출까지 이동해야 하는 거리 `k`가 2이므로 다음과 같은 경로로 탈출할 수 있습니다.

1. rd
2. dr

`"dr"`이 사전 순으로 가장 빠른 경로입니다. 따라서 `"dr"`을 return 해야 합니다.

입출력 예 #3

미로의 크기는 3 x 3입니다. 출발 지점은 (1, 2)이고, 탈출 지점은 (3, 3)입니다.

빈 공간은 `.`, 출발 지점을 `S`, 탈출 지점을 `E`로 나타내면 다음과 같습니다.

```
.S.
...
..E
```

미로의 좌측 상단은 (1, 1)이고 우측 하단은 (3, 3)입니다.

탈출까지 이동해야 하는 거리 `k`가 4입니다. 이때, 이동 거리가 4이면서, `S`에서 `E`까지 이동할 수 있는 경로는 존재하지 않습니다.

따라서 `"impossible"`을 return 해야 합니다.

---

## 문제 정보

| 난이도 | Lv.3 |
| ------ | ---- |
| 정답률 | 39%  |

## 풀이 정보

| 풀이 시간 | 50 min   |
| --------- | -------- |
| 알고리즘  | 중복순열 |

| 정확성 테스트                      |
| ---------------------------------- |
| 테스트 1 〉 통과 (0.15ms, 77.6MB)  |
| 테스트 2 〉 통과 (0.19ms, 75.5MB)  |
| 테스트 3 〉 통과 (0.03ms, 89.2MB)  |
| 테스트 4 〉 통과 (0.06ms, 74.2MB)  |
| 테스트 5 〉 통과 (0.07ms, 79.4MB)  |
| 테스트 6 〉 통과 (0.06ms, 83.2MB)  |
| 테스트 7 〉 통과 (0.06ms, 100MB)   |
| 테스트 8 〉 통과 (0.06ms, 79.6MB)  |
| 테스트 9 〉 통과 (1.46ms, 78.1MB)  |
| 테스트 10 〉 통과 (1.38ms, 93MB)   |
| 테스트 11 〉 통과 (1.49ms, 80.2MB) |
| 테스트 12 〉 통과 (1.41ms, 77.8MB) |
| 테스트 13 〉 통과 (1.45ms, 86.9MB) |
| 테스트 14 〉 통과 (1.48ms, 87.9MB) |
| 테스트 15 〉 통과 (1.35ms, 95.2MB) |
| 테스트 16 〉 통과 (1.52ms, 89.1MB) |
| 테스트 17 〉 통과 (1.47ms, 94.4MB) |
| 테스트 18 〉 통과 (1.45ms, 90.7MB) |
| 테스트 19 〉 통과 (1.46ms, 85MB)   |
| 테스트 20 〉 통과 (1.64ms, 78.7MB) |
| 테스트 21 〉 통과 (1.36ms, 86.3MB) |
| 테스트 22 〉 통과 (1.44ms, 80.4MB) |
| 테스트 23 〉 통과 (1.40ms, 94.4MB) |
| 테스트 24 〉 통과 (1.46ms, 89.9MB) |
| 테스트 25 〉 통과 (1.45ms, 77.4MB) |
| 테스트 26 〉 통과 (1.41ms, 92.8MB) |
| 테스트 27 〉 통과 (1.37ms, 93.7MB) |
| 테스트 28 〉 통과 (1.47ms, 94.9MB) |
| 테스트 29 〉 통과 (1.43ms, 92.3MB) |
| 테스트 30 〉 통과 (1.46ms, 83.6MB) |
| 테스트 31 〉 통과 (0.03ms, 80.6MB) |

## 코드

```java
class Solution {

    private static char[] arr;
    private static final char[] sel = {'d', 'l', 'r', 'u'};  // 오름차순으로 방향 설정
    private static String answer = "";

    public String solution(int n, int m, int x, int y, int r, int c, int k) {
        if (isImpossible(k, x, y, r, c)) return "impossible";

        arr = new char[k];
        permutation(0, k, n, m, x, y, r, c);

        return answer;
    }

    // 두 좌표간 거리 반환
    private static int distance(int x, int y, int r, int c) {
        return Math.abs(x - r) + Math.abs(y - c);
    }

    // 두 좌표간 거리가 남은 이동 횟수보다 크거나 남은 이동 횟수 - 거리가 짝수가 아니면 불가능한 상황
    private static boolean isImpossible(int times, int x, int y, int r, int c) {
        return distance(x, y, r, c) > times || (times - distance(x, y, r, c)) % 2 == 1;
    }

    private static void permutation(int selIdx, int len, int n, int m, int x, int y, int r, int c) {
        // 한번이라도 경로를 구하면 가지치기
        if (!answer.isEmpty()) return;

        // 현재 상황에서 불가능한 경로면 가지치기
        if (isImpossible(len - selIdx, x, y, r, c)) return;

        if (selIdx == len) {
            // 목적지에 도착하지 못하면 리턴
            if (!(x == r && y == c)) return;

            StringBuilder sb = new StringBuilder();
            for (char dir : arr) {
                sb.append(dir);
            }

            answer = sb.toString();
            return;
        }

        // 다음 방향이 이동가능한 방향이면 탐색
        for (char dir : sel) {
            if (dir == 'd') {
                if (x == n) continue;

                arr[selIdx] = dir;
                permutation(selIdx + 1, len, n, m, x + 1, y, r, c);
            } else if (dir == 'l') {
                if (y == 1) continue;

                arr[selIdx] = dir;
                permutation(selIdx + 1, len, n, m, x, y - 1, r, c);
            } else if (dir == 'r') {
                if (y == m) continue;

                arr[selIdx] = dir;
                permutation(selIdx + 1, len, n, m, x, y + 1, r, c);
            } else {
                if (x == 1) continue;

                arr[selIdx] = dir;
                permutation(selIdx + 1, len, n, m, x - 1, y, r, c);
            }
        }
    }
}
```

## 해설

사전순으로 앞서는 경로를 찾아야하므로 `d`, `l`, `r`, `u` 순으로 최대한 앞서는 경로를 찾아야한다. 이를 위해 사전순으로 경로를 탐색할 수 있게 방향 배열을 초기화하고 중복 순열로 경로를 탐색하는 방향을 접근했다. 경로의 경우 현재 위치에서 다음 위치가 미로 내부인지를 파악해서 내부면 이동하면서 좌표를 갱신하면 된다. 이후 `k`만큼 이동했을 때 목적지에 도착하면 `answer`를 선택한 방향들로 갱신해주는 방식으로 구현했다. 무작정 탐색하면 경우의 수가 매우 많아 가지치기 역시 필요한데 먼저 사전순으로 경로를 탐색하므로 한번만 정답을 구하면 더 이상 탐색을 진행할 필요가 없어서 정답을 구한 적이 있는지 판단하는 방식으로 리턴을 해줬다. 추가로 현재 위치와 목적지간 거리가 남은 이동 횟수보다 크거나 남은 이동 횟수 - 두 좌표간 거리가 홀수면 도달할 수 없는 상황으로 이 경우 역시 리턴을 해서 가지치기를 해줬다. 해당 상황은 초기에 불가능한 경로를 바로 판별하는데도 활용했다. 남은 이동 횟수 - 두 좌표간 거리가 짝수면 상하좌우 어디든 왔다갔다로 제자리로 돌아올 수 있기에 홀수인지로 구분하면 된다.

## 리뷰

기존에 지저분한 조건 처리로 해결했었는데 중복순열로도 가지치기만 하면 통과가 돼서 훨씬 깔끔해진 것 같다.

---
