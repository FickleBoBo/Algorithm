# [Programmers 138476 - 귤 고르기](https://school.programmers.co.kr/learn/courses/30/lessons/138476)

## 문제 설명

경화는 과수원에서 귤을 수확했습니다. 경화는 수확한 귤 중 'k'개를 골라 상자 하나에 담아 판매하려고 합니다. 그런데 수확한 귤의 크기가 일정하지 않아 보기에 좋지 않다고 생각한 경화는 귤을 크기별로 분류했을 때 서로 다른 종류의 수를 최소화하고 싶습니다.

예를 들어, 경화가 수확한 귤 8개의 크기가 [1, 3, 2, 5, 4, 5, 2, 3] 이라고 합시다. 경화가 귤 6개를 판매하고 싶다면, 크기가 1, 4인 귤을 제외한 여섯 개의 귤을 상자에 담으면, 귤의 크기의 종류가 2, 3, 5로 총 3가지가 되며 이때가 서로 다른 종류가 최소일 때입니다.

경화가 한 상자에 담으려는 귤의 개수 `k`와 귤의 크기를 담은 배열 `tangerine`이 매개변수로 주어집니다. 경화가 귤 k개를 고를 때 크기가 서로 다른 종류의 수의 최솟값을 return 하도록 solution 함수를 작성해주세요.

## 제한 사항

- 1 ≤ `k` ≤ `tangerine`의 길이 ≤ 100,000
- 1 ≤ `tangerine`의 원소 ≤ 10,000,000

## 입출력 예

| k   | tangerine                | result |
| --- | ------------------------ | ------ |
| 6   | [1, 3, 2, 5, 4, 5, 2, 3] | 3      |
| 4   | [1, 3, 2, 5, 4, 5, 2, 3] | 2      |
| 2   | [1, 1, 1, 1, 2, 2, 2, 3] | 1      |

## 입출력 예 설명

입출력 예 #1

- 본문에서 설명한 예시입니다.

입출력 예 #2

- 경화는 크기가 2인 귤 2개와 3인 귤 2개 또는 2인 귤 2개와 5인 귤 2개 또는 3인 귤 2개와 5인 귤 2개로 귤을 판매할 수 있습니다. 이때의 크기 종류는 2가지로 이 값이 최소가 됩니다.

입출력 예 #3

- 경화는 크기가 1인 귤 2개를 판매하거나 2인 귤 2개를 판매할 수 있습니다. 이때의 크기 종류는 1가지로, 이 값이 최소가 됩니다.

---

## 문제 정보

| 난이도 | Lv.2 |
| ------ | ---- |
| 정답률 | 72%  |

## 풀이 정보

| 풀이 시간 | 10 min |
| --------- | ------ |
| 알고리즘  | 정렬   |

| 정확성 테스트                       |
| ----------------------------------- |
| 테스트 1 〉 통과 (23.12ms, 97.9MB)  |
| 테스트 2 〉 통과 (19.40ms, 89.7MB)  |
| 테스트 3 〉 통과 (19.34ms, 101MB)   |
| 테스트 4 〉 통과 (22.82ms, 86.4MB)  |
| 테스트 5 〉 통과 (18.48ms, 101MB)   |
| 테스트 6 〉 통과 (23.81ms, 89.3MB)  |
| 테스트 7 〉 통과 (20.75ms, 85.6MB)  |
| 테스트 8 〉 통과 (18.64ms, 85MB)    |
| 테스트 9 〉 통과 (20.99ms, 83.2MB)  |
| 테스트 10 〉 통과 (22.09ms, 85.3MB) |
| 테스트 11 〉 통과 (0.41ms, 73MB)    |
| 테스트 12 〉 통과 (0.30ms, 80.6MB)  |
| 테스트 13 〉 통과 (0.26ms, 85.3MB)  |
| 테스트 14 〉 통과 (0.21ms, 85.5MB)  |
| 테스트 15 〉 통과 (0.21ms, 71.2MB)  |
| 테스트 16 〉 통과 (0.24ms, 83.4MB)  |
| 테스트 17 〉 통과 (0.22ms, 76.2MB)  |
| 테스트 18 〉 통과 (0.26ms, 85.5MB)  |
| 테스트 19 〉 통과 (0.22ms, 77.5MB)  |
| 테스트 20 〉 통과 (0.23ms, 85.2MB)  |
| 테스트 21 〉 통과 (0.96ms, 79.1MB)  |
| 테스트 22 〉 통과 (2.68ms, 81MB)    |
| 테스트 23 〉 통과 (1.78ms, 79.9MB)  |
| 테스트 24 〉 통과 (2.51ms, 85.6MB)  |
| 테스트 25 〉 통과 (11.35ms, 97.4MB) |
| 테스트 26 〉 통과 (14.68ms, 93.1MB) |
| 테스트 27 〉 통과 (63.07ms, 104MB)  |
| 테스트 28 〉 통과 (41.85ms, 89.5MB) |
| 테스트 29 〉 통과 (52.12ms, 90.5MB) |
| 테스트 30 〉 통과 (73.22ms, 101MB)  |
| 테스트 31 〉 통과 (19.90ms, 85.5MB) |
| 테스트 32 〉 통과 (26.75ms, 99.8MB) |
| 테스트 33 〉 통과 (52.34ms, 112MB)  |
| 테스트 34 〉 통과 (48.25ms, 89.7MB) |

## 코드

```java
import java.util.*;

class Solution {
    public int solution(int k, int[] tangerine) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int t : tangerine) {
            map.put(t, map.getOrDefault(t, 0) + 1);
        }

        List<Integer> list = new ArrayList<>(map.values());
        list.sort(Comparator.reverseOrder());  // 같은 크기의 귤의 개수에 대해 내림차순 정렬

        int sum = 0;
        int answer = 0;
        for (int v : list) {
            sum += v;
            answer++;

            if (sum >= k) break;
        }

        return answer;
    }
}
```

## 해설

귤의 종류의 수가 최소가 되게 하려면 같은 크기에서 귤의 수가 많은 종류부터 선택하면 된다. 해시맵을 활용해서 키에 귤의 크기, 값에 귤의 개수를 저장한 후 귤의 개수만 리스트로 뽑아서 내림차순 정렬을 수행했다. 이후 귤의 개수를 더하며 k개 이상이 되는 가짓수를 세어줬다.

## 리뷰

원리만 알면 간단하게 해결할 수 있는 문제였다.

---
