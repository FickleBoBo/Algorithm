# [Programmers 118667 - 두 큐 합 같게 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/118667)

## 문제 설명

길이가 같은 두 개의 큐가 주어집니다. 하나의 큐를 골라 원소를 추출(pop)하고, 추출된 원소를 다른 큐에 집어넣는(insert) 작업을 통해 각 큐의 원소 합이 같도록 만들려고 합니다. 이때 필요한 작업의 최소 횟수를 구하고자 합니다. 한 번의 pop과 한 번의 insert를 합쳐서 작업을 1회 수행한 것으로 간주합니다.

큐는 먼저 집어넣은 원소가 먼저 나오는 구조입니다. 이 문제에서는 큐를 배열로 표현하며, 원소가 배열 앞쪽에 있을수록 먼저 집어넣은 원소임을 의미합니다. 즉, pop을 하면 배열의 첫 번째 원소가 추출되며, insert를 하면 배열의 끝에 원소가 추가됩니다. 예를 들어 큐 `[1, 2, 3, 4]`가 주어졌을 때, pop을 하면 맨 앞에 있는 원소 1이 추출되어 `[2, 3, 4]`가 되며, 이어서 5를 insert하면 `[2, 3, 4, 5]`가 됩니다.

다음은 두 큐를 나타내는 예시입니다.

```
queue1 = [3, 2, 7, 2]
queue2 = [4, 6, 5, 1]
```

두 큐에 담긴 모든 원소의 합은 30입니다. 따라서, 각 큐의 합을 15로 만들어야 합니다. 예를 들어, 다음과 같이 2가지 방법이 있습니다.

1. queue2의 4, 6, 5를 순서대로 추출하여 queue1에 추가한 뒤, queue1의 3, 2, 7, 2를 순서대로 추출하여 queue2에 추가합니다. 그 결과 queue1은 [4, 6, 5], queue2는 [1, 3, 2, 7, 2]가 되며, 각 큐의 원소 합은 15로 같습니다. 이 방법은 작업을 7번 수행합니다.
2. queue1에서 3을 추출하여 queue2에 추가합니다. 그리고 queue2에서 4를 추출하여 queue1에 추가합니다. 그 결과 queue1은 [2, 7, 2, 4], queue2는 [6, 5, 1, 3]가 되며, 각 큐의 원소 합은 15로 같습니다. 이 방법은 작업을 2번만 수행하며, 이보다 적은 횟수로 목표를 달성할 수 없습니다.

따라서 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수는 2입니다.

길이가 같은 두 개의 큐를 나타내는 정수 배열 `queue1`, `queue2`가 매개변수로 주어집니다. 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수를 return 하도록 solution 함수를 완성해주세요. 단, 어떤 방법으로도 각 큐의 원소 합을 같게 만들 수 없는 경우, -1을 return 해주세요.

## 제한 사항

- 1 ≤ `queue1`의 길이 = `queue2`의 길이 ≤ 300,000
- 1 ≤ `queue1`의 원소, `queue2`의 원소 ≤ 10⁹
- 주의: 언어에 따라 합 계산 과정 중 산술 오버플로우 발생 가능성이 있으므로 long type 고려가 필요합니다.

## 입출력 예

| queue1       | queue2        | result |
| ------------ | ------------- | ------ |
| [3, 2, 7, 2] | [4, 6, 5, 1]  | 2      |
| [1, 2, 1, 2] | [1, 10, 1, 2] | 7      |
| [1, 1]       | [1, 5]        | -1     |

## 입출력 예 설명

입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

두 큐에 담긴 모든 원소의 합은 20입니다. 따라서, 각 큐의 합을 10으로 만들어야 합니다. queue2에서 1, 10을 순서대로 추출하여 queue1에 추가하고, queue1에서 1, 2, 1, 2와 1(queue2으로부터 받은 원소)을 순서대로 추출하여 queue2에 추가합니다. 그 결과 queue1은 [10], queue2는 [1, 2, 1, 2, 1, 2, 1]가 되며, 각 큐의 원소 합은 10으로 같습니다. 이때 작업 횟수는 7회이며, 이보다 적은 횟수로 목표를 달성하는 방법은 없습니다. 따라서 7를 return 합니다.

입출력 예 #3

어떤 방법을 쓰더라도 각 큐의 원소 합을 같게 만들 수 없습니다. 따라서 -1을 return 합니다.

---

## 문제 정보

| 난이도 | Lv.2 |
| ------ | ---- |
| 정답률 | 57%  |

## 풀이 정보

| 풀이 시간 | 13 min        |
| --------- | ------------- |
| 알고리즘  | 큐, 투 포인터 |

| 정확성 테스트                       |
| ----------------------------------- |
| 테스트 1 〉 통과 (0.24ms, 86.1MB)   |
| 테스트 2 〉 통과 (0.06ms, 78.1MB)   |
| 테스트 3 〉 통과 (0.05ms, 82.6MB)   |
| 테스트 4 〉 통과 (0.09ms, 87.3MB)   |
| 테스트 5 〉 통과 (0.30ms, 75.8MB)   |
| 테스트 6 〉 통과 (0.57ms, 77.4MB)   |
| 테스트 7 〉 통과 (0.51ms, 86.6MB)   |
| 테스트 8 〉 통과 (0.61ms, 91.3MB)   |
| 테스트 9 〉 통과 (0.90ms, 88.2MB)   |
| 테스트 10 〉 통과 (1.10ms, 89.1MB)  |
| 테스트 11 〉 통과 (29.95ms, 82.9MB) |
| 테스트 12 〉 통과 (15.91ms, 94.9MB) |
| 테스트 13 〉 통과 (10.27ms, 94.4MB) |
| 테스트 14 〉 통과 (11.80ms, 97.6MB) |
| 테스트 15 〉 통과 (19.50ms, 89.9MB) |
| 테스트 16 〉 통과 (17.57ms, 107MB)  |
| 테스트 17 〉 통과 (19.63ms, 98.5MB) |
| 테스트 18 〉 통과 (44.76ms, 136MB)  |
| 테스트 19 〉 통과 (37.61ms, 137MB)  |
| 테스트 20 〉 통과 (42.01ms, 144MB)  |
| 테스트 21 〉 통과 (38.03ms, 141MB)  |
| 테스트 22 〉 통과 (50.74ms, 140MB)  |
| 테스트 23 〉 통과 (70.43ms, 127MB)  |
| 테스트 24 〉 통과 (62.82ms, 140MB)  |
| 테스트 25 〉 통과 (0.69ms, 87.6MB)  |
| 테스트 26 〉 통과 (0.34ms, 88.3MB)  |
| 테스트 27 〉 통과 (0.32ms, 70.6MB)  |
| 테스트 28 〉 통과 (58.56ms, 100MB)  |
| 테스트 29 〉 통과 (3.40ms, 87.1MB)  |
| 테스트 30 〉 통과 (35.95ms, 105MB)  |

## 코드

```java
import java.util.*;

class Solution {
    public int solution(int[] queue1, int[] queue2) {
        Queue<Integer> q1 = init(queue1);
        Queue<Integer> q2 = init(queue2);
        long sum1 = addition(queue1);
        long sum2 = addition(queue2);
        int cnt = 0;
        int max = (q1.size() + q2.size()) * 2;  // 최대 비교 횟수

        while (cnt < max) {
            if (sum1 < sum2) {
                sum1 += q2.peek();
                sum2 -= q2.peek();
                q1.offer(q2.poll());
            } else if (sum1 > sum2) {
                sum1 -= q1.peek();
                sum2 += q1.peek();
                q2.offer(q1.poll());
            } else {
                return cnt;
            }

            cnt++;
        }

        return -1;
    }

    private static Queue<Integer> init(int[] arr) {
        Queue<Integer> q = new ArrayDeque<>();
        for (int n : arr) {
            q.offer(n);
        }
        return q;
    }

    private static long addition(int[] arr) {
        long sum = 0;
        for (int n : arr) {
            sum += n;
        }
        return sum;
    }
}
```

## 해설

투 포인터 알고리즘과 큐 자료구조의 조합으로 해결했다.

먼저 주어진 배열을 큐로 변환하여 연산을 편하게 할 수 있게 초기화했다. 각 배열의 합 역시 `long` 타입 변수로 저장했다. 이후 문제 조건에 맞춰 한 큐의 합이 더 크면 다른 큐에 옮기고 합을 갱신하다가 합이 같아지는 순간 종료하도록 했다. 이런 반복은 한 큐의 모든 원소가 다른 큐로 이동했다가 다시 자신의 큐로 돌아올 때까지 반복하면 이후 동일한 상황이 반복되므로 두 큐의 원소의 합 \* 2만큼만 반복하도록 했다.

## 리뷰

투 포인터 알고리즘에 대한 이해만 있으면 간단하게 접근할 수 있는 문제였다.

---
