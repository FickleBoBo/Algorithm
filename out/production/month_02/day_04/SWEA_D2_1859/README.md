# 🔍 백만 장자 프로젝트
- 설계 시간 : 14분
- 구현 시간 : 103분

---

# 💡 아이디어
- N을 준 걸로 보아 1차원 배열로 풀이하라는 뜻으로 이해
- 언제 판매를 할까 고민해봤을 때, 배열의 최댓값을 찾고 해당일에 전부 다 팔기
  - 최댓값 이후 인덱스부터 다시 최댓값을 찾고 이 과정을 반복하면 된다고 생각
  - 최댓값 인덱스 전까지만 순회해서 의미없는 뺄셈 배제
  - 최댓값이 배열의 마지막 값일때까지 반복 후 종료

ex)
- T=1
- N=10
- 1 1 3 9 2 5 6 7 5 3

| |0|1|2|3|4|5|6|7| 8 |9|
|-|-|-|-|-|-|-|-|-|-|-|
| |1|1|3|9|2|5|6|7|5|3|
|a|1|1|3|9| | | | | | |
|b| | | | |2|5|6|7| | |
|c| | | | | | | | |5| |
|d| | | | | | | | | |3|

- a = (9-1) + (9-1) + (9-3) = 22
- b = (7-2) + (7-5) + (7-6) = 8
- c = 0
- d = 0
- ans = a + b + c + d = 30

---

# 🧠 어려웠던 점
- D2라는게 믿기지 않을 정도로 은근 어려웠음
- 일단 input 파일을 console 창에 복붙에서 Run하면 T가 10이 아니라 12로 나오는 문제 발견
  - console 창에 많은 텍스트를 복붙할 경우 텍스트 씹힘 현상 때문인 것으로 추측
  - 적은 양을 테스트할 경우 정상 출력이 돼서 굉장히 골치가 아팠는데, 이 때문에 input 파일에 대해서 복붙이 아니라 file input을 써야함을 깨달음
  - BufferedReader를 활용해 모든 input을 받았는데 이 과정에서 int형 배열에 readLine을 바로 받지 못해 String[]으로 받고 형변환을 해주는 식으로 구현해서 굉장히 불편했음
    - 실행 시간도 길게 나왔는데 이 때문인 것으로 추측
- 테스트 케이스가 10개 중 4개만 통과돼서 골치가 아팠는데 종료 조건에 대한 설계가 미흡함을 발견함
  - max의 index가 맨 앞일 경우 종료하도록 했는데, 이 경우 남은 배열이 10, 4, 6 일 때 바로 종료가 됨을 깨달음
    - max가 배열의 마지막일때까지 돌고 종료해야 함
- 이후 테스트 케이스가 10개 중 7개가 통과됐는데 마지막 8, 9, 10번이 안돼서 왜일까 했는데 숫자의 크기가 크다는 것을 발견하고 세보니 49억 정도 값이었다
  - int형은 21억이 최대임이 생각나서 ans를 long형으로 바꿔주니 통과됨
  - 이 과정에서 문제를 읽고 설계할 때 정수형을 다룰 경우 범위를 꼭 신경써야 함을 깨달음(추후 중요해질 듯)

---

# 🧐 좋은 풀이
- 입력을 받아 배열에 저장할 때 Tokenizer 사용을 연습하자

```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(br.readLine());

int N = Integer.parseInt(br.readLine());
int[] arr = new int[N];
    
for(int i=0 ; i<N ; i++){
    arr[i] = Integer.parseInt(st.nextToken());
}
```
- 나는 일단 한 바퀴 돌면서 max를 찾고 계산 후 max 이후 부터 이 과정을 반복했음
- 근데 맨 뒷 값을 max로 두고 계산하다가 더 큰 값을 만나면 초기화해주는게 정석인 듯
  - 맨 뒷 값을 max로 두고 앞으로 순회할 경우 max보다 더 큰 값을 만나면 그 사이의 값은 가장 비싸게 판게 되고 max를 새롭게 바꿔주는 식으로 구현하는 듯