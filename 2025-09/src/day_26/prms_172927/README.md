# [Programmers 172927 - 광물 캐기](https://school.programmers.co.kr/learn/courses/30/lessons/172927)

## 문제 설명

마인은 곡괭이로 광산에서 광석을 캐려고 합니다. 마인은 다이아몬드 곡괭이, 철 곡괭이, 돌 곡괭이를 각각 0개에서 5개까지 가지고 있으며, 곡괭이로 광물을 캘 때는 피로도가 소모됩니다. 각 곡괭이로 광물을 캘 때의 피로도는 아래 표와 같습니다.

![](./assets/photo1.png)

예를 들어, 철 곡괭이는 다이아몬드를 캘 때 피로도 5가 소모되며, 철과 돌을 캘때는 피로도가 1씩 소모됩니다. 각 곡괭이는 종류에 상관없이 광물 5개를 캔 후에는 더 이상 사용할 수 없습니다.

마인은 다음과 같은 규칙을 지키면서 최소한의 피로도로 광물을 캐려고 합니다.

- 사용할 수 있는 곡괭이중 아무거나 하나를 선택해 광물을 캡니다.
- 한 번 사용하기 시작한 곡괭이는 사용할 수 없을 때까지 사용합니다.
- 광물은 주어진 순서대로만 캘 수 있습니다.
- 광산에 있는 모든 광물을 캐거나, 더 사용할 곡괭이가 없을 때까지 광물을 캡니다.

즉, 곡괭이를 하나 선택해서 광물 5개를 연속으로 캐고, 다음 곡괭이를 선택해서 광물 5개를 연속으로 캐는 과정을 반복하며, 더 사용할 곡괭이가 없거나 광산에 있는 모든 광물을 캘 때까지 과정을 반복하면 됩니다.

마인이 갖고 있는 곡괭이의 개수를 나타내는 정수 배열 `picks`와 광물들의 순서를 나타내는 문자열 배열 `minerals`가 매개변수로 주어질 때, 마인이 작업을 끝내기까지 필요한 최소한의 피로도를 return 하는 solution 함수를 완성해주세요.

## 제한 사항

- `picks`는 [dia, iron, stone]과 같은 구조로 이루어져 있습니다.
  - 0 ≤ dia, iron, stone ≤ 5
  - dia는 다이아몬드 곡괭이의 수를 의미합니다.
  - iron은 철 곡괭이의 수를 의미합니다.
  - stone은 돌 곡괭이의 수를 의미합니다.
  - 곡괭이는 최소 1개 이상 가지고 있습니다.
- 5 ≤ `minerals`의 길이 ≤ 50
  - `minerals`는 다음 3개의 문자열로 이루어져 있으며 각각의 의미는 다음과 같습니다.
  - diamond : 다이아몬드
  - iron : 철
  - stone : 돌

## 입출력 예

| picks     | minerals                                                                                                   | result |
| --------- | ---------------------------------------------------------------------------------------------------------- | ------ |
| [1, 3, 2] | ["diamond", "diamond", "diamond", "iron", "iron", "diamond", "iron", "stone"]                              | 12     |
| [0, 1, 1] | ["diamond", "diamond", "diamond", "diamond", "diamond", "iron", "iron", "iron", "iron", "iron", "diamond"] | 50     |

## 입출력 예 설명

입출력 예 #1

다이아몬드 곡괭이로 앞에 다섯 광물을 캐고 철 곡괭이로 남은 다이아몬드, 철, 돌을 1개씩 캐면 12(1 + 1 + 1 + 1+ 1 + 5 + 1 + 1)의 피로도로 캘 수 있으며 이때가 최소값입니다.

입출력 예 #2

철 곡괭이로 다이아몬드 5개를 캐고 돌 곡괭이고 철 5개를 캐면 50의 피로도로 캘 수 있으며, 이때가 최소값입니다.

---

## 문제 정보

| 난이도 | Lv.2 |
| ------ | ---- |
| 정답률 | 46%  |

## 풀이 정보

| 풀이 시간 | 44 min |
| --------- | ------ |
| 알고리즘  | 정렬   |

| 정확성 테스트                      |
| ---------------------------------- |
| 테스트 1 〉 통과 (0.50ms, 79.4MB)  |
| 테스트 2 〉 통과 (0.57ms, 80.1MB)  |
| 테스트 3 〉 통과 (0.51ms, 81.1MB)  |
| 테스트 4 〉 통과 (0.52ms, 73.4MB)  |
| 테스트 5 〉 통과 (0.48ms, 76MB)    |
| 테스트 6 〉 통과 (0.48ms, 89.2MB)  |
| 테스트 7 〉 통과 (0.60ms, 76.9MB)  |
| 테스트 8 〉 통과 (0.59ms, 88MB)    |
| 테스트 9 〉 통과 (0.54ms, 82.2MB)  |
| 테스트 10 〉 통과 (0.55ms, 78.1MB) |
| 테스트 11 〉 통과 (0.58ms, 80.8MB) |
| 테스트 12 〉 통과 (0.46ms, 75.5MB) |
| 테스트 13 〉 통과 (0.60ms, 70.1MB) |
| 테스트 14 〉 통과 (0.50ms, 84MB)   |
| 테스트 15 〉 통과 (0.50ms, 73.9MB) |
| 테스트 16 〉 통과 (0.49ms, 80.2MB) |
| 테스트 17 〉 통과 (0.50ms, 81.5MB) |
| 테스트 18 〉 통과 (0.65ms, 91.8MB) |
| 테스트 19 〉 통과 (0.66ms, 80.7MB) |
| 테스트 20 〉 통과 (0.54ms, 80.7MB) |
| 테스트 21 〉 통과 (0.46ms, 72.5MB) |
| 테스트 22 〉 통과 (0.50ms, 85.2MB) |
| 테스트 23 〉 통과 (0.68ms, 88.3MB) |
| 테스트 24 〉 통과 (0.57ms, 80.7MB) |
| 테스트 25 〉 통과 (0.65ms, 88.8MB) |
| 테스트 26 〉 통과 (0.60ms, 91.4MB) |
| 테스트 27 〉 통과 (0.75ms, 73.8MB) |
| 테스트 28 〉 통과 (0.59ms, 95.9MB) |
| 테스트 29 〉 통과 (0.79ms, 90.9MB) |
| 테스트 30 〉 통과 (0.70ms, 81.1MB) |
| 테스트 31 〉 통과 (0.52ms, 76.8MB) |
| 테스트 32 〉 통과 (0.50ms, 75.6MB) |
| 테스트 33 〉 통과 (0.77ms, 83.5MB) |
| 테스트 34 〉 통과 (0.77ms, 90.3MB) |
| 테스트 35 〉 통과 (0.48ms, 74MB)   |

## 코드

```java
import java.util.*;

class Solution {
    public int solution(int[] picks, String[] minerals) {
        // 곡괭이 수 세기
        int pickCnt = 0;
        for (int pick : picks) {
            pickCnt += pick;
        }

        // 곡괭이로 캘 수 있는 광물의 수와 주어진 광물의 수를 비교해서 어디까지 캘 수 있는지 계산
        int len = Math.min(pickCnt * 5, minerals.length);

        // 5개 단위 구간에서 각 광물의 수를 저장하는 2차원 배열
        int[][] map = new int[len + 1][3];
        for (int i = 0; i < len; i++) {
            if (minerals[i].equals("diamond")) {
                map[i / 5][0]++;
            } else if (minerals[i].equals("iron")) {
                map[i / 5][1]++;
            } else {
                map[i / 5][2]++;
            }
        }

        // 다이아몬드가 많을수록, 철이 많을수록 우선순위가 높은 구간
        Arrays.sort(map, (o1, o2) -> {
            if (o1[0] != o2[0]) return Integer.compare(o2[0], o1[0]);
            if (o1[1] != o2[1]) return Integer.compare(o2[1], o1[1]);
            return Integer.compare(o2[2], o1[2]);
        });

        // 우선순위가 높은 구간에 대해 피로도가 적게 드는 곡괭이부터 사용
        int answer = 0;
        for (int[] row : map) {
            if (picks[0] != 0) {
                answer += row[0] + row[1] + row[2];
                picks[0]--;
                continue;
            }

            if (picks[1] != 0) {
                answer += row[0] * 5 + row[1] + row[2];
                picks[1]--;
                continue;
            }

            if (picks[2] != 0) {
                answer += row[0] * 25 + row[1] * 5 + row[2];
                picks[2]--;
                continue;
            }

            break;
        }

        return answer;
    }
}
```

## 해설

곡괭이는 광물을 최대 5개까지 캘 수 있는데 피로도 표를 보면 곡괭이보다 단단한 광물을 캘 때 피로도가 5배, 25배 많이 드는 것을 볼 수 있다. 이를 통해 광물을 5개 단위로 구간을 나눌 때 더 단단한 광물이 하나라도 더 포함된 구간이 더 단단한 곡괭이를 사용해야 이득인 것을 볼 수 있다.

먼저 주어진 곡괭이의 수와 광물의 수를 비교해서 주어진 광물 중 어디까지 캘 수 있는지를 찾았다. 이후 각 구간을 행, 구간에서 각 광물의 수를 열로 둔 2차원 배열을 선언하고 값을 채웠다. 행이 각 구간이 되므로 아까의 우선 순위로 정렬까지 해줬다. 이러면 이제 앞 구간에 더 단단한 곡괭이를 사용하도록 하면 되며 표에 맞춰 계산하여 반환했다.

## 리뷰

기존에는 곡괭이를 순열로 돌려서 푸는 방식으로 해결했다가 이번엔 좀 더 간단한 로직으로 해결하였다. 순열 풀이가 시간은 더 빨랐는데 실전이었으면 그냥 이런 쉬운 로직이 더 나을 것 같다.

---
