# [Programmers 152996 - 시소 짝꿍](https://school.programmers.co.kr/learn/courses/30/lessons/152996)

## 문제 설명

어느 공원 놀이터에는 시소가 하나 설치되어 있습니다. 이 시소는 중심으로부터 2(m), 3(m), 4(m) 거리의 지점에 좌석이 하나씩 있습니다.  
이 시소를 두 명이 마주 보고 탄다고 할 때, 시소가 평형인 상태에서 각각에 의해 시소에 걸리는 토크의 크기가 서로 상쇄되어 완전한 균형을 이룰 수 있다면 그 두 사람을 시소 짝꿍이라고 합니다. 즉, 탑승한 사람의 무게와 시소 축과 좌석 간의 거리의 곱이 양쪽 다 같다면 시소 짝꿍이라고 할 수 있습니다.  
사람들의 몸무게 목록 `weights`이 주어질 때, 시소 짝꿍이 몇 쌍 존재하는지 구하여 return 하도록 solution 함수를 완성해주세요.

## 제한 사항

- 2 ≤ `weights`의 길이 ≤ 100,000
- 100 ≤ `weights`[i] ≤ 1,000
  - 몸무게 단위는 N(뉴턴)으로 주어집니다.
  - 몸무게는 모두 정수입니다.

## 입출력 예

| weights               | result |
| --------------------- | ------ |
| [100,180,360,100,270] | 4      |

## 입출력 예 설명

{100, 100} 은 서로 같은 거리에 마주보고 앉으면 균형을 이룹니다.  
{180, 360} 은 각각 4(m), 2(m) 거리에 마주보고 앉으면 균형을 이룹니다.  
{180, 270} 은 각각 3(m), 2(m) 거리에 마주보고 앉으면 균형을 이룹니다.  
{270, 360} 은 각각 4(m), 3(m) 거리에 마주보고 앉으면 균형을 이룹니다.

---

## 문제 정보

| 난이도 | Lv.2 |
| ------ | ---- |
| 정답률 | 54%  |

## 풀이 정보

| 풀이 시간 | 42 min |
| --------- | ------ |
| 알고리즘  | 해시맵 |

| 정확성 테스트                       |
| ----------------------------------- |
| 테스트 1 〉 통과 (0.10ms, 69.7MB)   |
| 테스트 2 〉 통과 (0.19ms, 88.7MB)   |
| 테스트 3 〉 통과 (0.32ms, 84MB)     |
| 테스트 4 〉 통과 (4.26ms, 99.6MB)   |
| 테스트 5 〉 통과 (13.13ms, 95.8MB)  |
| 테스트 6 〉 통과 (14.65ms, 81.2MB)  |
| 테스트 7 〉 통과 (9.50ms, 78MB)     |
| 테스트 8 〉 통과 (12.57ms, 96.7MB)  |
| 테스트 9 〉 통과 (18.56ms, 96.4MB)  |
| 테스트 10 〉 통과 (22.44ms, 103MB)  |
| 테스트 11 〉 통과 (20.11ms, 96MB)   |
| 테스트 12 〉 통과 (20.09ms, 103MB)  |
| 테스트 13 〉 통과 (24.02ms, 101MB)  |
| 테스트 14 〉 통과 (22.55ms, 88.6MB) |
| 테스트 15 〉 통과 (18.96ms, 87.7MB) |
| 테스트 16 〉 통과 (0.12ms, 69.2MB)  |
| 테스트 17 〉 통과 (0.10ms, 74.3MB)  |

## 코드

```java
import java.util.*;

class Solution {
    public long solution(int[] weights) {
        Map<Integer, Integer> map = new HashMap<>();

        for (int w : weights) {
            map.put(w, map.getOrDefault(w, 0) + 1);
        }

        long answer = 0;
        for (int w : map.keySet()) {
            long cnt = map.get(w);  // int형 오버플로우 방지

            answer += cnt * (cnt - 1) / 2;  // 같은 거리에 위치하는 경우
            answer += cnt * map.getOrDefault(w * 2, 0);  // 4m, 2m에 위치하는 경우
            if (w % 2 == 0) answer += cnt * map.getOrDefault(w * 3 / 2, 0);  // 3m, 2m에 위치하는 경우
            if (w % 3 == 0) answer += cnt * map.getOrDefault(w * 4 / 3, 0);  // 4m, 3m에 위치하는 경우
        }

        return answer;
    }
}
```

## 해설

시소에는 2, 3, 4 세 가지 지점이 있어서 지점별 조합을 구하면 (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (4, 4) 총 6가지가 있다. 이 중 같은 거리끼리는 시소 짝꿍을 중복 계산하게 되므로 크게 같은 거리 위치, (2, 3), (2, 4), (3, 4) 4가지 경우가 나오게 된다.

무게의 경우 중복되는 값이 존재할 수 있는데 [100, 100, 100]이 주어질 경우 3가지 시소 짝꿍이 존재하고 [100, 100, 200, 200]이 주어질 경우 (100, 100) 한 쌍, (200, 200) 한 쌍, (100, 200) 네 쌍으로 총 6가지 시소 짝꿍이 존재하게 된다.

중복되는 무게가 있고 무게별 인원 수가 필요해서 이를 해시맵을 통해 key에 무게, value에 인원 수로 처리하였고 각 key(무게)에 대해 위의 4가지 경우를 계산하는 방식으로 구현했다. 토크의 평형은 `A 무게 * A 거리 = B 무게 * B 거리`로 이를 통해 `A 무게 = B 무게 * B 거리 / A 거리`에 해당하는 무게가 있는지 해시맵에서 찾으면 되는데 무게는 정수이므로 모듈러 연산으로 가능한 케이스인지 먼저 체크해서 int형 나눗셈의 버림으로 인한 예외케이스를 방지했다.

## 리뷰

시소 짝꿍이 되는 케이스들이 중복되는 무게에서 어떻게 세어지는지 잘못 생각해서 구현에 시간이 좀 걸렸다.  
현재 무게의 인원수 \* 시소 짝꿍 후보 무게의 인원수를 계산하는 과정에서 int형 오버플로우가 발행하면 테스트 케이스 12 ~ 15를 틀리게 되는데 이걸 찾는게 좀 어려웠다.

---
